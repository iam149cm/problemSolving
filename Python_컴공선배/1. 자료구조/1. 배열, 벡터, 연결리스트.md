# 자료구조
## 배열
- 삽입/삭제 : O(N) 👉 느리다
> 리스트 중간에 삽입/삭제하는 경우 기존 리스트의 요소들을 하나씩 뒤로 밀어서 (or 앞으로 당겨서) 일일히 재할당해야 한다.
 
- 탐색 : O(1) 👉 빠르다
> 임의 접근 Random access : 메모리주소값을 한 번에 찾아서 접근한다.
- Python 은 리스트를 사용

```py
arr = [10, 11, 12, 13]
arr[2] = 5
```

## 벡터 Vector
- C++ 에서 사용되며 동적배열. 사이즈 변경 가능, 어떤 타입도 넣을 수 있다.
- 삽입/삭제 : O(N)
- 탐색 : O(1)

```py
v = []
v.append((123, 456))
v.append((789, 987))
print("size:" , len(v)) # 2
for p in v :
    print(p)
```

## 연결 리스트 Linked List
- 삽입/삭제 : O(1) 👉 빠르다
> 0. [ 5 | - ]  ---> [ 0 | - ] ---( 삽입 : [ 4 | - ] )---> [ 99 | - ]
>> 1. 기존 배열에서는 삽입을 위한 공간을 만들기 위해 값을 일일히 뒤로 미루어야 했다.
>> 2. 연결 리스트에서는 삽입하려는 위치의 링크만 변경하면 된다.

- 탐색 : O(N) 👉 느리다
> 0. [ 5 | - ]  ---> [ 0 | - ] ------> [ 99 | - ]
>> 1. 각 노드는 그 노드의 값과 주소값을 가지고 있고, 연결된 다음 노드가 어디 있는지는 그 이전 노드만 가지고 있다. 
>> 2. 임의접근을 제공하지 않는다. 즉 특정 노드를 탐색하기 위해서는 그 이전 노드까지 찾아야 한다. N번재 인덱스를 가기 위해서는 N개의 노드를 거쳐야 한다.

- 삽입/삭제를 자주 하는 경우 배열보다 연결리스트를 쓰면 좋다.
- PS 에서는 별로 안쓰이지만 다른 자료구조들을 구현할 때 많이 쓰인다.